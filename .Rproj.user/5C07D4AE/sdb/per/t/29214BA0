{
    "collab_server" : "",
    "contents" : "######################################\n#Reference code \n#\n######################################\n\n#----------------------------------------\n\n#library used \n#library(randomForest)\n#library(pROC) \n#library(class)\n#library(ggplot2)\n#library(ISLR)\n#library(boot)\n#library(leaps)\n#library(glmnet)\n\n\n#----------------------------------------\n\n\n\n#LOGIT info\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n#note this is the model verson \nconfusion.matrix <- function(model, p = 0.5){\n  predict <- predict(model, type = \"response\")\n  \n  #define levels reuquired\n  y.name<-model$terms[[2]]\n  y.data <- model$data[,colnames(model$data)==y.name]\n  y.levels <- levels(y.data)\n  \n  #predicted levels vs. normal\n  predict.levels <- rep(NA, length(predict))\n  predict.levels <- data.frame(y.data, predict.levels)\n  names(predict.levels) <- c(y.name, \"predict\")\n  predict.levels$predict[predict<p] <- y.levels[1]\n  predict.levels$predict[predict>=p] <- y.levels[2]\n  \n  #table - with right norder \n  t <- table(predict.levels)\n  t.out <- t[,rev(colnames(t))]\n  t.out <- t.out[rev(rownames(t)),]\n  return(t.out)\n}\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nrates.for.misclass <- function(confusion.matrix.in){\n  \n  misclassification.rate <- ( confusion.matrix.in[1,2] + confusion.matrix.in[2,1] ) / sum(confusion.matrix.in)\n  sensitivity <- confusion.matrix.in[1,1] / sum(confusion.matrix.in[1,])\n  specificity <- confusion.matrix.in[2,2] / sum(confusion.matrix.in[2,])\n  \n  list.out <- list(\n    misclassification.rate = misclassification.rate, \n    sensitivity = sensitivity, \n    specificity = specificity)\n  \n  return(list.out)\n  \n}\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\nmisclassification.rate.only <- function(confusion.matrix.in){\n  \n  misclassification.rate <- ( confusion.matrix.in[1,2] + confusion.matrix.in[2,1] ) / sum(confusion.matrix.in)\n\n  return(misclassification.rate)\n  \n}\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n## need to test & validate \n#note this is the model version \n## THIS IS WRONG --> COME BACK \n\n#ROC.table.glm <- function(model,sensativity=.01){\n#p0 <- rep(from = 0, to=1, by = sensativity)\n#\n#output <- data.frame(p0 = p0, \n#One.minus.Specificity = rep(NA, length(p0)), Sensativity = #rep(NA, length(p0)), \n  #Sens.minus.One.minus.Spec = rep(NA, length(p0)),\n  #True.Pos = rep(NA, length(p0)), True.Neg = rep(NA, length(#p0)),\n    #False.Pos = rep(NA, length(p0)), False.Neg = rep(NA, length(#p0)))\n      #for(i in p0){\n      #conf.matrix <- confusion.matrix(model, i)\n      #index <- output$p0==i\n      #    \n      #output$True.Pos[index] <- conf.matrix[1,1]\n      #output$True.Neg[index] <- conf.matrix[2,2]\n      #output$False.Pos[index] <- conf.matrix[2,1]\n      #output$False.Neg[index] <- conf.matrix[1,2]\n      #    \n      #rates <- rates.for.misclass(conf.matrix)\n      #output$One.minus.Specificity[index] <- 1 - rates$specificity\n      #output$Sensativity[index] <- rates$sensitivity\n      #output$Sens.minus.One.minus.Spec[index] <- output$Sensativity[index] - #output$One.minus.Specificity[index] \n        #}\n        #  \n        #return(output)\n        #  \n        #}\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nassign.one.value <- function(predicted.prob, p=.5, true.value=1, false.value=0){\n  output <- rep(NA, length(predicted.prob))\n  output[predicted.prob>=p] <- true.value\n  output[predicted.prob<p] <- false.value\n  return(output)\n}\n\nmis.class.rate.data.in <- function(actual.in, predicted.prob, p=.5, true.value=1, false.value=0 ){\n  \n  predicted.val  <- assign.one.value(predicted.prob, p, true.value, false.value)\n  incorrect <- sum( actual.in != predicted.val)\n  mis.rate <- incorrect / length(actual.in)\n  return(mis.rate)\n}\n\n\nROC.table.predicted.prob <- function(predicted.prob, actual.value, p.sensativity = 0.01, true.value =1, false.value =0){\n  \n  p <- seq(from = 0, to = 1, by = p.sensativity)\n  output <- data.frame(p = p, \n                       One.minus.Specificity = rep(NA, length(p)), Sensativity = rep(NA, length(p)), \n                       Sens.minus.One.minus.Spec = rep(NA, length(p)),\n                       True.Pos = rep(NA, length(p)), True.Neg = rep(NA, length(p)),\n                       False.Pos = rep(NA, length(p)), False.Neg = rep(NA, length(p)),\n                       mis.class = rep(NA, length(p)))\n  \n  for(i in p){\n    predicted.value <-assign.one.value(predicted.prob = predicted.prob, p = i, true.value = true.value, false.value = false.value)\n    \n    index <- output$p==i\n    \n    output$True.Pos[index] <- sum(actual.value[actual.value==true.value]==predicted.value[actual.value==true.value])\n    output$True.Neg[index] <- sum(actual.value[actual.value==false.value]==predicted.value[actual.value==false.value])\n    \n    output$False.Pos[index] <- sum(actual.value[actual.value==false.value]!=predicted.value[actual.value==false.value])\n    output$False.Neg[index] <- sum(actual.value[actual.value==true.value]!=predicted.value[actual.value==true.value])\n    \n    output$One.minus.Specificity[index] <- 1 - ( output$True.Neg[index] / (output$True.Neg[index] + output$False.Pos[index]) ) \n    output$Sensativity[index] <- ( output$True.Pos[index] ) / (  output$True.Pos[index] + output$False.Neg[index] )\n    output$Sens.minus.One.minus.Spec[index] <- output$Sensativity[index] - output$One.minus.Specificity[index] \n    \n    output$mis.class[index] <- ( output$False.Pos[index] + output$False.Neg[index]) / (length(actual.value))\n  }\n  \n  return(output)\n}\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n#this is the value of mis.classification vs. k for a KNN regression \n\nknn.k.vs.mis.class <- function(train, val, correct.train, correct.val, possible.k){\n  \n  output <- data.frame(k = possible.k)\n  \n  for(k in possible.k){\n    knn.out <- knn(train = train, test = val, cl = correct.train, k = k)\n    conf.matrix <- table(correct.val, knn.out)\n    mis.class.rate <-misclassification.rate.only(conf.matrix)\n    output$mis.class.rate[output$k==k] <- mis.class.rate\n  }\n  return(output)\n}\n\n\n\n\n\n\n\n\n\n\n\n#TO DO --> MAKE A FUNCTION that loops over the knn.k.vs.mis.class !!! --> THIS IS MORE THAN I WANT TO DO RIGHT NOW \n\n\n\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n#predicted based on regsubsets output -->!!\n\n\npredict.regsubsets.coeff <- function(coef, data.in, intercept = TRUE){\n  start <- 1\n  matched.columns <- match(names(coef),names(data.in))\n  predicted <- rep(0, nrow(data.in))\n  \n  if(intercept){\n    predicted <- predicted + coef[1]*rep(1, nrow(data.in))\n    start <- 2\n  }\n  \n  array <- start:length(matched.columns)\n  \n  for(i in array){\n    predicted <- predicted + coef[i]*data.in[,matched.columns[i]]\n  }\n  return(predicted)\n}\n\n\npredict.book <- function(object, newdata ,id ,...){\n  form=as.formula(object$call[[2]])\n  mat=model.matrix(form,newdata)\n  coefi=coef(object ,id=id)\n  xvars=names(coefi)\n  mat[,xvars]%*%coefi \n}\n\n\n\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#predicted based on lasso and ridge output -->!!\n\n\n\npredict.lass.ridge.coeff <- function(coef, data.in, intercept = TRUE){\n  start <- 1\n  matched.columns <- match(names(coef[,1]),names(data.in))\n  predicted <- rep(0, nrow(data.in))\n  \n  if(intercept){\n    predicted <- predicted + coef[1]*rep(1, nrow(data.in))\n    start <- 2\n  }\n  \n  array <- start:length(matched.columns)\n  \n  for(i in array){\n    predicted <- predicted + coef[i]*data.in[,matched.columns[i]]\n  }\n  return(predicted)\n}\n\n\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nRMSE <- function(actual, predicted){\n  MSE <- mean( (actual - predicted) ^2 )\n  RMSE <- sqrt(MSE)\n  return(RMSE)\n}\n\n\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n\n## OTHER STUFFF\n\n## ------------------------------------------------------------------------\ntimer.start <- function(name = \"Timer 1\"){ # A single argument \n  a <- Sys.time() # Save the current time into \"a\"\n  return(list(NAME = name, START = a))  # Return the list\n}\n\ntimer.stop <- function(st){ # \"st\" is the output from \"timer.start\"  \n  b <- Sys.time() # Save the current time\n  elapsed.time <- b - st[[\"START\"]] # Work out the elapsed time\n  print (paste(st[[\"NAME\"]], \"took:\", # A human readable message\n               elapsed.time, attributes(elapsed.time)$units)) \n}\n\n## ------------------------------------------------------------------------\n\n",
    "created" : 1487207812592.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3874865137",
    "id" : "29214BA0",
    "lastKnownWriteTime" : 1487207915,
    "last_content_update" : 1487207915385,
    "path" : "~/Dropbox/Wharton/z Other/1 Water start up/Mesa/Mesa/Code book v06.R",
    "project_path" : "Code book v06.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}